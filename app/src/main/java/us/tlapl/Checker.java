/*
 * This source file was generated by the Gradle 'init' task
 */
package us.tlapl;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import tla2sany.semantic.ModuleNode;

public class Checker {
	
	private class State {
		
	}
	
	private List<State> getInitialStates(ModuleNode root) {
		return new ArrayList<State>();
	}
	
	private List<State> getSuccessorStates(ModuleNode root, State current) {
		return new ArrayList<State>();
	}
	
	private long getStateHash(State s) {
		return 0;
	}
	
	private boolean satisfiesInvariants(ModuleNode root, State s) {
		return true;
	}
	
	private List<State> reconstructStateTrace(ModuleNode root, Map<Long, Long> predecessors, State last) {
		ArrayList<Long> hashes = new ArrayList<Long>();
		long current = getStateHash(last);
		while (current != 0L) {
			hashes.add(current);
			current = predecessors.get(current);
		}
		
		ArrayList<State> trace = new ArrayList<State>();
		List<State> nextStates = getInitialStates(root);
		for (long nextStateHash : hashes.reversed()) {
			State nextState = null;
			for (State candidate : nextStates) {
				if (nextStateHash == getStateHash(candidate)) {
					nextState = candidate;
					break;
				}
			}
			if (null == nextState) {
				System.err.println("ERROR: Unable to reconstruct state trace.");
			} else {
				trace.add(nextState);
				nextStates = getSuccessorStates(root, nextState);
			}
		}
		return trace;
	}
	
	private List<State> check(ModuleNode root) {
		Map<Long, Long> predecessors = new HashMap<Long, Long>();
		Deque<State> queue = new ArrayDeque<State>();
		List<State> initialStates = getInitialStates(root);
		queue.addAll(initialStates);
		for (State init : initialStates) {
			predecessors.put(getStateHash(init), 0L);
		}

		while (!queue.isEmpty()) {
			State current = queue.removeFirst();
			long currentHash = getStateHash(current);
			for (State next : getSuccessorStates(root, current)) {
				long nextHash = getStateHash(next);
				if (!predecessors.containsKey(nextHash)) {
					predecessors.put(nextHash, currentHash);
					if (!satisfiesInvariants(root, next)) {
						return reconstructStateTrace(root, predecessors, next);
					}
					queue.push(next);
				}
			}
		}
		
		return null;
	}
	
	public Checker() { }
  
    public static void main(String[] args) throws IOException {
    	if (args.length > 0) {
   			Path spec = Path.of(args[0]);
    		try {
    			ModuleNode root = Parser.parse(spec);
    			Checker mc = new Checker();
    			List<State> failureTrace = mc.check(root);
    			if (null == failureTrace) {
    				System.out.println("Success!");
    			} else {
    				System.out.println("Failure.");
    			}
    		} catch (IOException e) {
              System.err.println("Failed to read file " + spec.toString());
            }
    	} else {
    		System.err.println("Missing CLI parameter: spec path");
    	}
    }
}
